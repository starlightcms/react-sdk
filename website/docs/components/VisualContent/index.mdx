---
sidebar_position: 1
---
import { Example, ExcerptExample, CustomExample } from './_examples'
import CodeBlock from '@theme/CodeBlock'
import styles from './index.module.scss'

# VisualContent

## Componente {#component}

<APILink href="/api/function/VisualContent" />

O componente [VisualContent](/api/function/VisualContent) renderiza conte√∫do de um campo de Editor Visual do Starlight
em HTML.

Para fins ilustrativos, esse √© um exemplo de um conte√∫do b√°sico renderizado nessa p√°gina:

<Example />

N√≥s escrevemos nosso pr√≥prio objeto `content` nesse exemplo, mas em aplica√ß√µes de verdade voc√™ n√£o precisa fazer isso.
Esse objeto com informa√ß√µes de conte√∫do √© retornado pelo Starlight sempre que um modelo utiliza um campo do
tipo Visual Editor.

Dito isso, esse √© um exemplo de uso mais pr√≥ximo da realidade:

```jsx
import Starlight, { VisualContent } from '@starlightcms/react-sdk'

// Assuma que criamos um modelo de postagens de blog que usa o slug "posts",
// e que criamos um campo de Editor Visual com a chave "post_content".
const EntryComponent = ({ slug }) => {
  const [entry, setEntry] = useState(null)

  // Esse √© apenas um exemplo, voc√™ pode requisitar
  // uma entrada da maneira que preferir.
  useEffect(async () => {
    const response = await Starlight.posts.entries.get(slug)

    setEntry(response.data)
  }, [ slug ])

  // Depois da requisi√ß√£o, o conte√∫do vai estar na propriedade `entry.data.post_content`.
  return (
    entry ? (
       <article>
         <h1>{entry.title}</h1>
         <VisualContent content={entry.data.post_content} />
       </article>
    ) : (
      <div>Carregando...</div>
    )
  )
}
```

## Resumindo o conte√∫do {#content-excerpts}

O componente [VisualContent](#component) suporta a propriedade `excerpt` que, se passada, limita o conte√∫do renderizado
a 40 palavras. Essa fun√ß√£o √© √∫til para gerar resumos do conte√∫do em listagens, como, por exemplo, em uma p√°gina de
posts de um blog, onde cada post s√≥ precisa de um r√°pido resumo do seu conte√∫do.

Voc√™ tamb√©m pode alterar a tamanho do resumo utilizando a propriedade `excerptLength`, que recebe o n√∫mero m√°ximo de
palavras que ser√£o renderizadas. Por padr√£o, o n√∫mero m√°ximo de palavras √© 40. Ao atingir esse limite, o texto √© cortado
e termina em retic√™ncias (...).

Para exemplificar, vamos reutilizar o exemplo no in√≠cio dessa p√°gina:

<ExcerptExample />

Note que, no exemplo acima, o cabe√ßalho "Ol√°, mundo! üòÉ" n√£o foi renderizado. Isso acontece porque, ao passar a
propriedade `excerpt`, o componente renderiza apenas blocos de par√°grafo, ignorando todo o resto, como cabe√ßalhos,
imagens, listas, embeds, etc. Isso garante que o conte√∫do renderizado n√£o vai "quebrar" o layout da sua aplica√ß√£o.

## Personalizando componentes {#customizing-components}

O componente [VisualContent](#component) tamb√©m permite que voc√™ personalize como blocos s√£o renderizados. Para isso,
basta passar um objeto de componentes personalizados pela propriedade `components`. Cada componente recebe um objeto
com o conte√∫do a ser renderizado, e pode renderizar esse conte√∫do da maneira que preferir.

Por exemplo, por padr√£o, blocos de lista s√£o renderizados utilizando elementos `<ul>` ou `<ol>`, dependendo se essas
listas s√£o ordenadas ou sem ordem. Se quisermos mudar esse comportamento, podemos criar um componente personalizado para
isso.

No exemplo abaixo, vamos renderizar listas ordenadas como texto simples separado por v√≠rgulas, mas vamos
renderizar listas sem ordem sem altera√ß√µes, utilizando o componente original:

<CustomExample />

Todos os componentes que renderizam blocos podem ser personalizados, e os tipos de bloco suportados est√£o listados na
tabela abaixo. Para substituir um componente, passe um objeto para a propriedade `components` onde cada chave √© um tipo
da tabela abaixo, assim como foi feito com o componente `list` no exemplo acima.

Todo componente recebe um objeto do tipo [VisualDataBlock](/api/interface/VisualDataBlock) que cont√©m 3 propriedades:
`id`, `type` e `data`.

- `id` pode ser usado para identificar o bloco atual dentro do conte√∫do.
- `type` √© uma string com o tipo do bloco atual.
- `data` √© um objeto com o conte√∫do do bloco.

A propriedade `data` √© gen√©rica e seu conte√∫do depende do `type` do bloco. Voc√™ pode clicar no link da terceira coluna
da tabela abaixo para saber quais dados a propriedade `data` ter√° para seu respectivo tipo de bloco.

Na quarta coluna, voc√™ pode ver qual componente do SDK renderiza esse tipo de bloco por padr√£o, o que pode ser √∫til
para servir de refer√™ncia na hora de implementar um componente customizado.

### Classes CSS {#css-classes}

| Classe CSS             | Descri√ß√£o                                                                                                                                         |
|------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| `sl-visual-content`    | Utilizada pelo elemento que envolve todos os componentes da p√°gina                                                                                |
| `sl-content-block`     | Utilizada por cada um dos elementos que envolvem cada um dos blocos (ver se√ß√£o de [Blocos suportados](#supported-blocks))                         |
| `sl-header`            | Utilizada pelo elemento que envolve um bloco de cabe√ßalho                                                                                         |
| `sl-quote`             | Utilizada pelo elemento que envolve um bloco de cita√ß√£o                                                                                           |
| `sl-html`              | Utilizada pelo elemento que envolve um bloco de HTML                                                                                              |
| `sl-image`             | Utilizada pelo elemento que envolve um bloco de imagem                                                                                            |
| `sl-list`              | Utilizada pelo elemento que envolve um bloco de lista                                                                                             |
| `sl-list__root`        | Utilizada pelo elemento do bloco de lista                                                                                                         |
| `sl-paragraph`         | Utilizada pelo elemento que envolve um bloco de par√°grafo                                                                                         |
| `empty`                | Utilizada pelo elemento que envolve um bloco de par√°grafo vazio                                                                                   |
| `sl-video`             | Utilizada pelo elemento que envolve um bloco de v√≠deo                                                                                             |
| `sl-width-fixed`       | Utilizada pelos elementos que envolvem um bloco de imagem ou v√≠deo cuja largura √© fixa (definida pelio usu√°rio)                                   |
| `sl-width-auto`        | Utilizada pelos elementos que envolvem um bloco de imagem ou v√≠deo cuja largura √© definida automaticamente (vira a largura inicial da imagem)     |
| `sl-width-justify`     | Utilizada pelos elementos que envolvem um bloco de imagem ou v√≠deo cuja largura √© justificada ao texto (ou seja, ter√° a mesma largura do texto)   |
| `sl-width-max`         | Utilizada pelos elementos que envolvem um bloco de imagem ou v√≠deo cuja largura √© m√°xima (a maior poss√≠vel)                                       |

### Blocos suportados {#supported-blocks}

| Nome do bloco | Tipo        | Dados recebidos pelo componente                 | Componente padr√£o                                      |
|---------------|-------------|-------------------------------------------------|--------------------------------------------------------|
| Cabe√ßalho     | `header`    | [HeaderBlock](/api/interface/HeaderBlock)       | [HeaderComponent](/api/function/HeaderComponent)       |
| Cita√ß√£o       | `quote`     | [QuoteBlock](/api/interface/QuoteBlock)         | [QuoteComponent](/api/function/QuoteComponent)         |
| HTML          | `raw`       | [HTMLBlock](/api/interface/HTMLBlock)           | [HTMLComponent](/api/function/HTMLComponent)           |
| Imagem        | `image`     | [ImageBlock](/api/interface/ImageBlock)         | [ImageComponent](/api/function/ImageComponent)         |
| Lista         | `list`      | [ListBlock](/api/interface/ListBlock)           | [ListComponent](/api/function/ListComponent)           |
| Par√°grafo     | `paragraph` | [ParagraphBlock](/api/interface/ParagraphBlock) | [ParagraphComponent](/api/function/ParagraphComponent) |
| V√≠deo         | `video`     | [VideoBlock](/api/interface/VideoBlock)         | [VideoComponent](/api/function/VideoComponent)         |

### Largura dos blocos {#block-width}

Por padr√£o, os blocos de conte√∫do utilizam todo o espa√ßo horizontal disponibilizado pelo elemento pai do VisualContent, 
e a largura dos blocos dentro de um Visual Editor pode ser facilmente controlada por meio da interface do Starlight. Nela, 
o usu√°rio pode escolher dentre 4 tipos de largura: fixa, autom√°tica, justificada e m√°xima. 

Na fixa, o usu√°rio define manualmente a largura do bloco em pixels ou porcentagem do tamanho total do conte√∫do. Na 
autom√°tica, a largura do bloco √© definida como a largura original do bloco (por exemplo, se uma imagem tiver 200 pixels 
de largura, a largura ser√° definida como 200 pixels). Na justificada, a largura √© definida como a mesma largura do texto. 
J√° na m√°xima, a largura ser√° a maior poss√≠vel, por√©m o desenvolvedor ter√° de criar CSS adicional para que esta largura
funcione como esperado.

#### Largura m√°xima {#max-width}

Os blocos podem ter naturalmente uma largura limite, se voc√™ assim projetar. Abaixo h√° um pequeno exemplo de c√≥digo que 
limita a largura desses blocos a 500 pixels:

```css
.sl-content-block {
  max-width: 500px;
}
```

Contudo, blocos com largura m√°xima sempre utilizar√£o 100% do espa√ßo dispon√≠vel, independente do limite definido. Dessa 
maneira, voc√™ pode criar um design onde blocos com largura m√°xima ocupar√£o 100% da largura da tela.

Digamos que voc√™ tenha um blog onde o conte√∫do das postagens √© centralizado na p√°gina e voc√™ quer que a largura de certos 
blocos (como algumas imagens) exceda a largura a padr√£o do conte√∫do para efeito de √™nfase.

<figure>
  <picture>
    <source media="(prefers-color-scheme: dark)" srcSet={require("./assets/_beforeafterdark.png").default} />
    <source media="(prefers-color-scheme: light)" srcSet={require("./assets/_beforeafterlight.png").default} />
    <IdealImage img={require('./assets/_beforeafterlight.png')} />
  </ picture>
  <figcaption>Depois da atualiza√ß√£o, os blocos de conte√∫do continuam tendo uma largura definida, mas os blocos que t√™m largura m√°xima ocupam todo o espa√ßo dispon√≠vel na tela.</figcaption>
</ figure>


No exemplo do blog, digamos que o elemento de classe `.parent-component` tenha uma largura de 1000 pixels - isso √©
representado pelo "antes" na imagem acima e no c√≥digo abaixo. Para atualizar a largura do conte√∫do, voc√™ deve definir a largura do 
elemento de classe `.parent-component` como 100% da largura da tela (por exemplo) e a largura do elemento de classe 
`.sl-content-block` como 1000 pixels:

<div className={styles.maxWidthExamples}>
  <div>
    <CodeBlock language="css" title="Antes" >
{`.parent-component {
  width: 1000px;
}`}
    </CodeBlock>
  </div>
  <div>
    <CodeBlock language="css" title="Depois" >
      {`.parent-component {
  width: 100%;
}
      
.sl-content-block {
  max-width: 1000px;
}`}
    </CodeBlock>
  </div>
</div>


### Imagens responsivas {#responsive-images}

O componente [ImageComponent](/api/function/ImageComponent), que renderiza blocos do tipo `image` por padr√£o, prov√™ uma
propriedade adicional para dar suporte a imagens responsivas: a propriedade `sizes`. Essa propriedade define
[o atributo de mesmo nome na tag `<img>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-sizes) que √©
renderizada.

Essa propriedade serve para permitir que o navegador use a imagem de melhor tamanho dentre as varia√ß√µes geradas pelo
Starlight de acordo com o tamanho da tela do usu√°rio. Voc√™ pode aprender mais sobre essa propriedade [na p√°gina do MDN
sobre imagens responsivas](https://developer.mozilla.org/pt-BR/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images#mudan%C3%A7a_de_resolu%C3%A7%C3%A3o_diferentes_tamanhos).
Voc√™ s√≥ precisa definir a propriedade `sizes`: o atributo `srcset` √© automaticamente gerado pelo ImageComponent.

Por padr√£o, a propriedade `sizes` tem o valor de `'(max-width: 480px) 90vw, 70vw'`, que funciona bem para a maioria
dos sites. Para alterar essa propriedade, voc√™ s√≥ precisa criar um componente de imagem personalizado:

```jsx
import { VisualContent, ImageComponent } from '@starlightcms/react-sdk'

const CustomImageComponent = (props) => {
  return (
    // Voc√™ s√≥ precisa definir a propriedade "sizes" e repassar todos os props.
    <ImageComponent
      sizes="(max-width: 320px) 90vw, (max-width: 900px) 300px, 500px"
      {...props}
    />
  )
}

const ResponsiveImageExample = () => {
  const content = {
    time: 1663784614074,
    version: '1.42',
    blocks: [...]
  }

  return (
    <VisualContent
      content={content}
      components={{
        image: CustomImageComponent
      }}
    />
  )
}
```
